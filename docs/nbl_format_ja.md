# **NBL ファイルフォーマット仕様 (v1.0 Final)**

### **グローバル標準**

1. **エンディアン:** すべてのマルチバイト値は **Little-Endian (リトルエンディアン)** を使用。
2. **文字列エンコーディング:** すべての文字列は **UTF-8** を使用し、先頭に 2 バイトの `uint16` で長さを指定。
3. **圧縮アルゴリズム:** データブロックには **Zstd (Zstandard)** アルゴリズムを使用。ランダムアクセスをサポートするため、各フレームは独立して圧縮（コンテキスト依存なし）される必要がある。
4. **座標系:** Minecraft ネイティブ座標系 (1.0 = 1 ブロック)。
5. **アライメント:** データは密に配置され、パディングはなし。

---

### **1. ファイルヘッダー**

*固定長: 48 バイト*
*ファイルの先頭に位置し、再生に必要なメタデータを含む。*

| オフセット | フィールド名 | 型 | 説明 |
| --- | --- | --- | --- |
| 0x00 | `Magic` | `char[8]` | ASCII 固定値: **`NEBULAFX`** |
| 0x08 | `Version` | `uint16` | 固定値: **`1`** |
| 0x0A | `TargetFPS` | `uint16` | 記録時のフレームレート (30 または 60 推奨) |
| 0x0C | `TotalFrames` | `uint32` | アニメーションの総フレーム数 |
| 0x10 | `TextureCount` | `uint16` | テクスチャの総数 (N) |
| 0x12 | `Attributes` | `uint16` | ビットマスク: `0x01`=Alphaあり, `0x02`=Sizeあり (現バージョンではデフォルト 3) |
| 0x14 | `BBoxMin` | `float[3]` | アニメーション全体の AABB 最小点 (x, y, z)、視錐台カリング用 |
| 0x20 | `BBoxMax` | `float[3]` | アニメーション全体の AABB 最大点 (x, y, z)、視錐台カリング用 |
| 0x2C | `Reserved` | `byte[4]` | 予約領域、0 固定 |

---

### **2. テクスチャ定義ブロック**

*ファイルヘッダーの直後に配置。レンダラーに `Texture2DArray` へロードするテクスチャを通知する。*

**構造:** `TextureCount` 回繰り返して読み込む。

```c
struct TextureEntry {
    uint16 pathLength;       // パス文字列のバイト長
    char   path[pathLength]; // テクスチャパス (例: "minecraft:textures/particle/flame.png")
    uint8  rows;             // アニメーションの行数 (静止画は 1)
    uint8  cols;             // アニメーションの列数 (静止画は 1)
}
```

---

### **3. フレームインデックステーブル**

*テクスチャ定義ブロックの直後に配置。*
*プレイヤーは初期化時にこのテーブルをメモリに読み込み、各フレームをストリーミング再生する。*

**構造:** `TotalFrames` 回繰り返して読み込む。

| フィールド名 | 型 | 説明 |
| --- | --- | --- |
| `ChunkOffset` | `uint64` | **ファイル先頭**からの圧縮フレームブロックのバイトオフセット |
| `ChunkSize` | `uint32` | 圧縮フレームブロックのバイトサイズ |

---

### **4. キーフレームインデックステーブル**

*フレームインデックステーブルの直後に配置。*

**目的:** すべての I-Frame (Type 0) のフレーム番号を記録し、高速シークを可能にする。

| フィールド名 | 型 | 説明 |
| --- | --- | --- |
| `KeyframeCount` | `uint32` | キーフレームの総数 (K) |
| `KeyframeIndices` | `uint32[K]` | 昇順のキーフレーム番号リスト (例: 0, 60, 120...) |

---

### **5. フレームデータチャンク**

*ファイルの残り領域に配置。シークテーブルを使用して特定。*

> **実装上の重要事項:**
> 1. **圧縮境界:** Zstd 圧縮の入力は **`[チャンクヘッダー] + [ペイロード]`** を連結したものである必要がある。
> * **誤り:** `Header + Zstd(Payload)` (デコーダーがマジックナンバーを読み取れずエラーになる)。
> * **正しい:** `Zstd(Header + Payload)`。解凍後の最初の 1 バイトが `FrameType` である必要がある。
> 
> 2. **独立性:** 各フレームは **Clean Context (クリーンなコンテキスト)** で圧縮する必要がある。前のフレームの辞書状態に依存するストリーミング圧縮は禁止。

**解凍後のデータ構造** (総サイズ = 5 + ペイロードサイズ):

| オフセット | フィールド名 | 型 | 説明 |
|-------------|-----------------|----------|----------------------------------|
| 0x00        | `FrameType`     | `uint8`  | **0 = I-Frame**; **1 = P-Frame** |
| 0x01        | `ParticleCount` | `uint32` | 現在のフレームの粒子数 (N) |
| 0x05        | `Payload`       | `bytes`  | データ本体 (FrameType に基づいて解析) |

---

### **5.2 ペイロード: Type 0 (I-Frame 全量フレーム)**

*`FrameType == 0` の場合に使用。*
***SoA (Structure of Arrays)** レイアウトを採用し、パディングなしで密に配置。*

**物理メモリレイアウト:**
各配列が順番に連結。`N` に基づいてオフセットを計算する。

| 順序 | ブロック名 | データ型 | バイト長 | 詳細なメモリレイアウト (厳守) |
|----|-------------|-----------|-------------|----------------------------------|
| 1  | `PosArrays` | `float32` | `3 * N * 4` | **非インターリーブ方式:**<br>1. `N` 個の X 座標 (`float32` x N)<br>2. `N` 個の Y 座標 (`float32` x N)<br>3. `N` 個の Z 座標 (`float32` x N) |
| 2 | `ColArrays` | `uint8` | `4 * N * 1` | **非インターリーブ方式:**<br>1. `N` 個の R 成分 (`uint8` x N)<br>2. `N` 個の G 成分<br>3. `N` 個の B 成分<br>4. `N` 個の A 成分 |
| 3 | `Sizes` | `uint16` | `N * 2` | `N` 個のサイズ値 |
| 4 | `TextureIDs` | `uint8` | `N * 1` | `N` 個のテクスチャ ID |
| 5 | `SeqIndices` | `uint8` | `N * 1` | `N` 個のシーケンスインデックス |
| 6 | `ParticleIDs` | `int32` | `N * 4` | `N` 個の固有粒子 ID |

> **オフセット計算例:**
> * `OFFSET_X = 5` (ヘッダー後)
> * `OFFSET_Y = OFFSET_X + (N * 4)`
> * `OFFSET_Z = OFFSET_Y + (N * 4)`
> * `OFFSET_R = OFFSET_Z + (N * 4)`

---

### **5.3 ペイロード: Type 1 (P-Frame 差分フレーム)**

*`FrameType == 1` の場合に使用。*
*I-Frame と同様に SoA レイアウトに従う。*

| 順序 | ブロック名 | データ型 | バイト長 | 詳細なメモリレイアウト |
|----|-------------|---------|-------------|---------------------------|
| 1  | `PosDeltas` | `int16` | `3 * N * 2` | 1. `N` 個の dX (`int16`)<br>2. `N` 個の dY<br>3. `N` 個の dZ |
| 2 | `ColDeltas` | `int8` | `4 * N * 1` | 1. `N` 個の dR (`int8`)<br>2. `N` 個の dG<br>3. `N` 個の dB<br>4. `N` 個の dA |
| 3 | `SizeDeltas` | `int16` | `N * 2` | `N` 個の dSize 値 |
| 4 | `TexIDDeltas` | `int8` | `N * 1` | `N` 個の dTexID 値 |
| 5 | `SeqDeltas` | `int8` | `N * 1` | `N` 個の dSeq 値 |
| 6 | `ParticleIDs` | `int32` | `N * 4` | `N` 個の粒子 ID (前フレームとの照合用) |

### **6. 開発者向け実装ルール**

#### **A. パーティクルライフサイクル論理**

**P-Frame** を解析する際、`ParticleIDs` に基づいて以下の 3 つのシナリオを処理する：

1. **更新 (Update):**
* 現在のフレームと前のフレームの両方に ID `100` が存在。
* 処理: `State[100] += Delta`。

2. **生成 (Spawn):**
* 現在のフレームに ID `101` が存在するが、前のフレームには存在しない。
* 処理: **ゼロ基準原則**。`PrevState[101]` のすべてのプロパティを 0 と見なす。
* つまり: `State[101].x = 0.0 + (dx / 1000.0)`。
* *注意:* 新しい粒子が生成されたとき、P-Frame 内の Delta は実質的にその絶対初期値（量子化係数を乗じたもの）となる。

3. **消滅 (Despawn):**
* 前のフレームに ID `99` が存在したが、現在のフレームには存在しない。
* 処理: レンダリングリストから ID `99` を削除。

#### **B. 量子化の精度に関する警告**

* **位置:** `int16` + `1000x` スケールは、1 フレームあたりの最大移動距離が **32.7 ブロック** を超えられないことを意味する。
* 粒子が 32 ブロック以上ワープする場合、ジェネレーターは **必ず** そのフレームを I-Frame としてマークするか、その粒子を削除して新しい ID で再生成する必要がある。
* **サイズ:** `int16` + `100x` スケールは、サイズの変化範囲が ±327.67 であることを意味し、ほとんどの用途に十分。
